<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sissy Soccer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        #container {
            text-align: center;
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .menu {
            display: none;
        }
        
        .menu.active {
            display: block;
        }
        
        button {
            background: #1e3a8a;
            color: white;
            border: 2px solid #4b5563;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #1e40af;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        #gameCanvas {
            border: 4px solid #374151;
            display: none;
            box-shadow: 0 8px 16px rgba(0,0,0,0.5);
        }
        
        #gameCanvas.active {
            display: block;
        }
        
        .scoreboard {
            background: #1e40af;
            padding: 1.5rem 2rem;
            border-radius: 8px 8px 0 0;
            display: none;
            justify-content: space-between;
            width: 800px;
            margin: 0 auto;
        }
        
        .scoreboard.active {
            display: flex;
        }
        
        .score {
            font-size: 1.3rem;
            font-weight: bold;
        }
        
        .timer {
            font-size: 1.5rem;
            font-family: 'Courier New', monospace;
        }
        
        .controls {
            color: #9ca3af;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        
        .winner-screen {
            display: none;
            margin-top: 2rem;
        }
        
        .winner-screen.active {
            display: block;
        }
        
        .winner-text {
            font-size: 2.5rem;
            margin-bottom: 2rem;
        }
        
        .team-label {
            font-size: 1.2rem;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Main Menu -->
        <div id="mainMenu" class="menu active">
            <h1>Sissy Soccer</h1>
            <p style="margin-bottom: 1rem; color: #9ca3af;">Written by Quin Pendragon (originally)</p>
            <p style="margin-bottom: 2rem; color: #9ca3af;">Adapted by Claude</p>
            <button onclick="selectMode('single')">Single Player</button>
            <button onclick="selectMode('multi')">Multiplayer</button>
        </div>
        
        <!-- Duration Menu -->
        <div id="durationMenu" class="menu">
            <h2 style="margin-bottom: 2rem;">Select Game Duration</h2>
            <div class="team-label">
                <span style="color: #00CED1;">Cyan Team</span>
                <span style="margin: 0 1rem;">vs</span>
                <span style="color: #DC143C;">Red Team</span>
            </div>
            <div style="margin: 2rem 0;">
                <button onclick="startGame(60)">1 Minute</button>
                <button onclick="startGame(120)">2 Minutes</button>
                <button onclick="startGame(240)">4 Minutes</button>
                <button onclick="startGame(480)">8 Minutes</button>
                <button onclick="startGame(300)">World Cup (5 min)</button>
            </div>
            <div class="controls" id="controlsText"></div>
            <button onclick="backToMain()" style="margin-top: 1rem; background: #374151;">Back</button>
        </div>
        
        <!-- Game Screen -->
        <div id="gameScreen" class="menu">
            <div id="scoreboard" class="scoreboard">
                <span class="score" id="leftScore">Cyan Team: 0</span>
                <span class="timer" id="timer">00:00</span>
                <span class="score" id="rightScore">0 : Red Team</span>
            </div>
            <canvas id="gameCanvas" width="800" height="400"></canvas>
        </div>
        
        <!-- Winner Screen -->
        <div id="winnerScreen" class="winner-screen">
            <div class="winner-text" id="winnerText"></div>
            <button onclick="backToMain()">Back to Menu</button>
        </div>
    </div>

    <script>
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 400;
        const GROUND_HEIGHT = 80;
        const SLIME_RADIUS = 40;
        const BALL_RADIUS = 50;  // 5x bigger (was 10)
        const GOAL_WIDTH = 80;
        const GOAL_HEIGHT = 120;
        const GRAVITY = 0.6;
        const SLIME_SPEED = 5;
        const SLIME_JUMP_POWER = -12;
        const BALL_DAMPING = 0.99;
        const BALL_BOUNCE_DAMPING = 0.8;
        const MAX_BALL_SPEED = 26;  // 2x faster max speed (was 13)
        const AI_REACTION_DISTANCE = 300;
        const AI_PREDICTION_TIME = 30;

        let playerMode = null;
        let gameActive = false;
        let animationId = null;
        let timeLeft = 0;
        let score = { left: 0, right: 0 };
        let keys = {};
        let timerInterval = null;
        let lastFrameTime = 0;

        const gameState = {
            leftSlime: {
                x: 200,
                y: GAME_HEIGHT - GROUND_HEIGHT,
                vx: 0,
                vy: 0,
                isGrabbing: false,
                hasBall: false,
                goalLineTime: 0,
                // AI state persistence
                targetX: 200,
                lastDecisionTime: 0,
                decisionCooldown: 0,
                stableStart: true,
                lastBallY: 0,
                stuckCounter: 0
            },
            rightSlime: {
                x: 600,
                y: GAME_HEIGHT - GROUND_HEIGHT,
                vx: 0,
                vy: 0,
                isGrabbing: false,
                hasBall: false,
                goalLineTime: 0
            },
            ball: {
                x: GAME_WIDTH / 2,
                y: 150,
                vx: 0,
                vy: 0,
                grabbedBy: null,
                grabAngle: 0,
                grabAngularVelocity: 0
            }
        };

        // Keyboard handling
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            e.preventDefault();
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            e.preventDefault();
        });

        function selectMode(mode) {
            playerMode = mode;
            document.getElementById('mainMenu').classList.remove('active');
            document.getElementById('durationMenu').classList.add('active');
            
            const controlsText = mode === 'single'
                ? 'Use Arrow Keys: ↑/Space (jump), ←/→ (move), ↓ (grab)<br>Hold ↓ to grab the ball when it\'s near!'
                : 'Left Team: W (jump), A/D (move), S (grab)<br>Right Team: ↑/Space (jump), ←/→ (move), ↓ (grab)';
            
            document.getElementById('controlsText').innerHTML = controlsText;
        }

        function startGame(duration) {
            timeLeft = duration;
            score = { left: 0, right: 0 };
            resetPositions();
            
            document.getElementById('durationMenu').classList.remove('active');
            document.getElementById('gameScreen').classList.add('active');
            document.getElementById('scoreboard').classList.add('active');
            document.getElementById('gameCanvas').classList.add('active');
            
            updateScore();
            updateTimer();
            
            gameActive = true;
            
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimer();
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
            
            gameLoop();
        }

        function endGame() {
            gameActive = false;
            clearInterval(timerInterval);
            cancelAnimationFrame(animationId);
            
            document.getElementById('gameScreen').classList.remove('active');
            document.getElementById('scoreboard').classList.remove('active');
            document.getElementById('gameCanvas').classList.remove('active');
            
            const winnerScreen = document.getElementById('winnerScreen');
            const winnerText = document.getElementById('winnerText');
            
            if (score.left > score.right) {
                winnerText.textContent = 'Cyan Team Wins!';
            } else if (score.right > score.left) {
                winnerText.textContent = 'Red Team Wins!';
            } else {
                winnerText.textContent = 'It\'s a Draw!';
            }
            
            winnerScreen.classList.add('active');
        }

        function backToMain() {
            gameActive = false;
            clearInterval(timerInterval);
            cancelAnimationFrame(animationId);
            
            document.querySelectorAll('.menu, .scoreboard, #gameCanvas, .winner-screen').forEach(el => {
                el.classList.remove('active');
            });
            
            document.getElementById('mainMenu').classList.add('active');
            playerMode = null;
        }

        function updateScore() {
            document.getElementById('leftScore').textContent = `Cyan Team: ${score.left}`;
            document.getElementById('rightScore').textContent = `${score.right} : Red Team`;
        }

        function updateTimer() {
            const mins = Math.floor(timeLeft / 60);
            const secs = timeLeft % 60;
            document.getElementById('timer').textContent = 
                `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function resetPositions() {
            gameState.leftSlime = {
                x: 200, y: GAME_HEIGHT - GROUND_HEIGHT, vx: 0, vy: 0,
                isGrabbing: false, hasBall: false, goalLineTime: 0,
                targetX: 200, lastDecisionTime: 0, decisionCooldown: 0,
                stableStart: true, lastBallY: 0, stuckCounter: 0
            };
            gameState.rightSlime = {
                x: 600, y: GAME_HEIGHT - GROUND_HEIGHT, vx: 0, vy: 0,
                isGrabbing: false, hasBall: false, goalLineTime: 0
            };
            gameState.ball = {
                x: GAME_WIDTH / 2, y: 150, vx: 0, vy: 0,
                grabbedBy: null, grabAngle: 0, grabAngularVelocity: 0
            };
        }

        function updateAI() {
            if (playerMode !== 'single') return;

            const ai = gameState.leftSlime;
            const opponent = gameState.rightSlime;
            const ball = gameState.ball;
            const currentTime = Date.now();

            // Ultra-fast reaction system - almost instant decisions
            if (ai.decisionCooldown > 0) {
                ai.decisionCooldown--;
                const difference = ai.targetX - ai.x;
                const absDistance = Math.abs(difference);

                if (absDistance > 3) {
                    const speedMultiplier = Math.min(absDistance / 30, 1.0);
                    ai.vx = Math.sign(difference) * SLIME_SPEED * speedMultiplier * 3.0;
                } else {
                    ai.vx = 0;
                }
                return;
            }

            // Removed stable start - AI is aggressive from the beginning
            if (ai.stableStart) {
                ai.stableStart = false;
            }

            // Enhanced AI parameters
            const FIELD_WIDTH = GAME_WIDTH;
            const OPPONENT_GOAL_X = FIELD_WIDTH - GOAL_WIDTH / 2;
            const AI_GOAL_X = GOAL_WIDTH / 2;
            const aggressiveness = 0.95;

            // Advanced ball trajectory prediction with more frames
            let predictions = [];
            let tempX = ball.x;
            let tempY = ball.y;
            let tempVx = ball.vx;
            let tempVy = ball.vy;

            for (let t = 0; t < 150; t++) {
                tempVy += GRAVITY;
                tempVx *= BALL_DAMPING;
                tempX += tempVx;
                tempY += tempVy;

                if (tempX < BALL_RADIUS) {
                    tempX = BALL_RADIUS;
                    tempVx = -tempVx * BALL_BOUNCE_DAMPING;
                }
                if (tempX > FIELD_WIDTH - BALL_RADIUS) {
                    tempX = FIELD_WIDTH - BALL_RADIUS;
                    tempVx = -tempVx * BALL_BOUNCE_DAMPING;
                }

                predictions.push({ x: tempX, y: tempY, vx: tempVx, vy: tempVy, time: t });

                if (tempY > GAME_HEIGHT - GROUND_HEIGHT - BALL_RADIUS) {
                    tempY = GAME_HEIGHT - GROUND_HEIGHT - BALL_RADIUS;
                    tempVy = -tempVy * BALL_BOUNCE_DAMPING;
                    if (Math.abs(tempVy) < 1) break;
                }
            }

            // Enhanced game state analysis
            const ballDistanceToOpponentGoal = Math.abs(ball.x - OPPONENT_GOAL_X);
            const ballDistanceToAIGoal = Math.abs(ball.x - AI_GOAL_X);
            const aiDistanceToBall = Math.abs(ai.x - ball.x);
            const opponentDistanceToBall = Math.abs(opponent.x - ball.x);
            const ballMovingTowardsAIGoal = ball.vx < -0.5;
            const ballMovingTowardsOpponentGoal = ball.vx > 0.5;
            const ballHeight = GAME_HEIGHT - GROUND_HEIGHT - ball.y;
            const scoreDeficit = score.right - score.left;
            const urgencyMultiplier = Math.max(1.0, 1 + scoreDeficit * 0.3);

            // Track if ball is stuck
            if (!ai.lastBallY) ai.lastBallY = ball.y;
            if (!ai.stuckCounter) ai.stuckCounter = 0;

            const ballStuck = Math.abs(ball.y - ai.lastBallY) < 3 && Math.abs(ball.vx) < 1.5;
            if (ballStuck) {
                ai.stuckCounter++;
            } else {
                ai.stuckCounter = 0;
            }
            ai.lastBallY = ball.y;

            // Strategic decision-making with 3x speed
            let newTargetX = ai.targetX;
            let shouldJump = false;
            let shouldGrab = false;
            let moveSpeed = SLIME_SPEED * 3.0;

            // CRITICAL DEFENSE - Highest priority
            if ((ball.x < GOAL_WIDTH * 3 && ballMovingTowardsAIGoal) ||
                (ball.x < GOAL_WIDTH * 2 && ball.y > GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT)) {

                // Emergency goal defense with blazing speed
                newTargetX = Math.max(ball.x - 15, SLIME_RADIUS + 10);
                moveSpeed = SLIME_SPEED * 3.5;

                // Aggressive blocking jumps
                if (aiDistanceToBall < 100 && (ballHeight < 120 || ball.vy > 0)) {
                    shouldJump = true;
                }

                // Try to grab low balls
                if (ballHeight < 40 && aiDistanceToBall < 70) {
                    shouldGrab = true;
                }
            }
            // ULTRA-AGGRESSIVE OFFENSE
            else if (ball.x > FIELD_WIDTH * 0.4 ||
                     ballDistanceToOpponentGoal < ballDistanceToAIGoal * 1.3 ||
                     ai.hasBall) {

                // Predictive positioning based on ball trajectory
                let attackX = ball.x - 25;

                // Find best attack position from predictions
                for (let pred of predictions) {
                    if (pred.x > FIELD_WIDTH * 0.5 && pred.time < 40) {
                        const timeToReach = Math.abs(ai.x - pred.x) / (SLIME_SPEED * 1.2);
                        const predHeight = GAME_HEIGHT - GROUND_HEIGHT - pred.y;

                        if (timeToReach <= pred.time + 3 && predHeight < 100) {
                            attackX = pred.x - 20;
                            break;
                        }
                    }
                }

                newTargetX = attackX;
                moveSpeed = SLIME_SPEED * 3.2 * urgencyMultiplier;

                // Advanced offensive maneuvers
                if (aiDistanceToBall < 120) {
                    // Unstick ball with jump
                    if (ai.stuckCounter > 15) {
                        shouldJump = true;
                        newTargetX = ball.x - 30;
                    }
                    // Grab low balls aggressively
                    else if (ballHeight < 45 && aiDistanceToBall < 65 && !ai.hasBall) {
                        shouldGrab = true;
                    }
                    // Aerial attacks - jump to hit ball towards goal
                    else if (ballHeight > 35 && ballHeight < 110) {
                        if (ai.y >= GAME_HEIGHT - GROUND_HEIGHT - 1) {
                            const timeToReachBall = aiDistanceToBall / (SLIME_SPEED * 1.2);
                            const predictedBallY = ball.y + ball.vy * timeToReachBall + 0.5 * GRAVITY * timeToReachBall * timeToReachBall;
                            const predictedHeight = GAME_HEIGHT - GROUND_HEIGHT - predictedBallY;

                            // Jump if ball will be at good hitting height
                            if (predictedHeight > 20 && predictedHeight < 130) {
                                shouldJump = true;
                            }
                        }
                    }
                    // Jump over opponent's block
                    else if (opponentDistanceToBall < aiDistanceToBall &&
                             opponent.x < ball.x &&
                             aiDistanceToBall < 150) {
                        shouldJump = true;
                    }
                }

                // Strategic grab release for powerful shots
                if (ai.hasBall) {
                    const distToGoal = Math.abs(ai.x - OPPONENT_GOAL_X);
                    const ballGrabAngle = ball.grabAngle || 0;

                    // Release when positioned well for shot
                    if (distToGoal < 350 && (
                        Math.abs(ballGrabAngle) > 0.3 ||
                        ai.x > FIELD_WIDTH * 0.65 ||
                        Math.abs(ai.vx) > 3
                    )) {
                        shouldGrab = false;
                    }
                }
            }
            // SMART DEFENSE & INTERCEPTION
            else if (ball.x < FIELD_WIDTH * 0.5 || ballMovingTowardsAIGoal) {
                let bestInterceptX = ball.x - 20;
                let bestInterceptTime = 999;

                // Find optimal interception point
                for (let pred of predictions) {
                    if (pred.x < FIELD_WIDTH * 0.45) {
                        const timeToReach = Math.abs(ai.x - pred.x) / (SLIME_SPEED * 1.3);
                        const predHeight = GAME_HEIGHT - GROUND_HEIGHT - pred.y;

                        if (timeToReach <= pred.time + 3 && predHeight < 150 && pred.time < bestInterceptTime) {
                            bestInterceptX = pred.x - 15;
                            bestInterceptTime = pred.time;

                            // Jump to intercept if timing is right
                            if (timeToReach < pred.time && pred.time < 25 && predHeight > 30) {
                                shouldJump = true;
                            }
                            break;
                        }
                    }
                }

                newTargetX = Math.max(bestInterceptX, SLIME_RADIUS + 5);
                moveSpeed = SLIME_SPEED * 3.3;

                // Defensive grab
                if (ballHeight < 40 && aiDistanceToBall < 70) {
                    shouldGrab = true;
                }

                // Unstick defensive ball
                if (ai.stuckCounter > 12 && ball.x < FIELD_WIDTH * 0.35) {
                    shouldJump = true;
                    newTargetX = ball.x + 20;
                }
            }
            // MIDFIELD DOMINANCE
            else {
                newTargetX = FIELD_WIDTH * 0.35;

                // Predictive midfield positioning
                for (let pred of predictions) {
                    const predHeight = GAME_HEIGHT - GROUND_HEIGHT - pred.y;
                    if (predHeight < 80 && pred.x > FIELD_WIDTH * 0.3 && pred.x < FIELD_WIDTH * 0.5) {
                        const timeToReach = Math.abs(ai.x - pred.x) / (SLIME_SPEED * 1.2);
                        if (timeToReach < pred.time && pred.time < 35) {
                            newTargetX = pred.x - 20;
                            if (pred.time < 25 && ai.y >= GAME_HEIGHT - GROUND_HEIGHT - 1) {
                                shouldJump = true;
                            }
                            break;
                        }
                    }
                }
            }

            // Lightning-fast decision updates - minimal threshold
            if (Math.abs(newTargetX - ai.targetX) > 8) {
                ai.targetX = newTargetX;
                ai.decisionCooldown = 2; // Ultra-fast - reduced from 5
            }

            // Advanced grab logic with hold duration
            if (shouldGrab && !ai.isGrabbing && ai.y >= GAME_HEIGHT - GROUND_HEIGHT - 1) {
                ai.isGrabbing = true;
                ai.grabStartTime = currentTime;
            } else if (!shouldGrab || (ai.grabStartTime && currentTime - ai.grabStartTime > 800)) {
                ai.isGrabbing = false;
                ai.grabStartTime = null;
            }

            // Lightning-fast precise movement control
            const difference = ai.targetX - ai.x;
            const absDistance = Math.abs(difference);

            if (absDistance > 3) {
                const speedMultiplier = Math.min(absDistance / 30, 1.0);
                ai.vx = Math.sign(difference) * moveSpeed * speedMultiplier;
            } else {
                ai.vx = 0;
            }

            // Enhanced jump execution - can jump while moving
            if (shouldJump && ai.vy === 0) {
                ai.vy = SLIME_JUMP_POWER;
            }
        }

        function updatePhysics() {
            // Player controls
            if (playerMode === 'multi') {
                // Left player (WASD)
                gameState.leftSlime.vx = keys['a'] ? -SLIME_SPEED : keys['d'] ? SLIME_SPEED : 0;
                if (keys['w'] && gameState.leftSlime.y >= GAME_HEIGHT - GROUND_HEIGHT - 1) {
                    gameState.leftSlime.vy = SLIME_JUMP_POWER;
                }
                gameState.leftSlime.isGrabbing = keys['s'];
                
                // Right player (Arrows)
                gameState.rightSlime.vx = keys['arrowleft'] ? -SLIME_SPEED : keys['arrowright'] ? SLIME_SPEED : 0;
                if ((keys['arrowup'] || keys[' ']) && gameState.rightSlime.y >= GAME_HEIGHT - GROUND_HEIGHT - 1) {
                    gameState.rightSlime.vy = SLIME_JUMP_POWER;
                }
                gameState.rightSlime.isGrabbing = keys['arrowdown'];
            } else {
                // Single player - human on right, AI on left
                gameState.rightSlime.vx = keys['arrowleft'] ? -SLIME_SPEED : keys['arrowright'] ? SLIME_SPEED : 0;
                if ((keys['arrowup'] || keys[' ']) && gameState.rightSlime.y >= GAME_HEIGHT - GROUND_HEIGHT - 1) {
                    gameState.rightSlime.vy = SLIME_JUMP_POWER;
                }
                gameState.rightSlime.isGrabbing = keys['arrowdown'];
                
                updateAI();
            }
            
            // Update slimes
            [gameState.leftSlime, gameState.rightSlime].forEach((slime, idx) => {
                slime.vy += GRAVITY;
                slime.x += slime.vx;
                slime.y += slime.vy;
                
                if (slime.x < SLIME_RADIUS) slime.x = SLIME_RADIUS;
                if (slime.x > GAME_WIDTH - SLIME_RADIUS) slime.x = GAME_WIDTH - SLIME_RADIUS;
                
                if (slime.y > GAME_HEIGHT - GROUND_HEIGHT) {
                    slime.y = GAME_HEIGHT - GROUND_HEIGHT;
                    slime.vy = 0;
                }
                
                // Goal camping detection
                const isLeft = idx === 0;
                const inGoal = (isLeft && slime.x < GOAL_WIDTH) || (!isLeft && slime.x > GAME_WIDTH - GOAL_WIDTH);
                
                if (inGoal) {
                    slime.goalLineTime += 1/60;
                    if (slime.goalLineTime >= 1) {
                        if (isLeft) score.right++; else score.left++;
                        updateScore();
                        resetPositions();
                    }
                } else {
                    slime.goalLineTime = 0;
                }
            });
            
            // Ball physics
            const ball = gameState.ball;
            if (ball.grabbedBy) {
                const grabber = ball.grabbedBy === 'left' ? gameState.leftSlime : gameState.rightSlime;
                const slimeDirection = ball.grabbedBy === 'left' ? 1 : -1;

                // Apply rotational physics based on slime movement
                ball.grabAngularVelocity += -grabber.vx * 0.008 * slimeDirection;
                ball.grabAngularVelocity *= 0.85;
                ball.grabAngle += ball.grabAngularVelocity;

                // Constrain angle based on slime direction
                if (ball.grabbedBy === 'left') {
                    // Left slime: constrain between -π/2 and π/2
                    if (ball.grabAngle < -Math.PI / 2) {
                        ball.grabAngle = -Math.PI / 2;
                        ball.grabAngularVelocity = 0;
                    } else if (ball.grabAngle > Math.PI / 2) {
                        ball.grabAngle = Math.PI / 2;
                        ball.grabAngularVelocity = 0;
                    }
                } else {
                    // Right slime: keep angle between π/2 and 3π/2
                    while (ball.grabAngle < 0) ball.grabAngle += Math.PI * 2;
                    while (ball.grabAngle > Math.PI * 2) ball.grabAngle -= Math.PI * 2;

                    if (ball.grabAngle < Math.PI / 2 && ball.grabAngle >= 0) {
                        ball.grabAngle = Math.PI / 2;
                        ball.grabAngularVelocity = 0;
                    } else if (ball.grabAngle > 3 * Math.PI / 2 ||
                               (ball.grabAngle < Math.PI / 2 && ball.grabAngle < 0)) {
                        ball.grabAngle = 3 * Math.PI / 2;
                        ball.grabAngularVelocity = 0;
                    }
                }

                const holdDistance = SLIME_RADIUS + BALL_RADIUS - 5;
                ball.x = grabber.x + Math.cos(ball.grabAngle) * holdDistance;
                ball.y = grabber.y + Math.sin(ball.grabAngle) * holdDistance;
                ball.vx = grabber.vx;
                ball.vy = grabber.vy;

                if (!grabber.isGrabbing) {
                    const releaseAngle = ball.grabAngle;
                    const releaseSpeed = Math.abs(ball.grabAngularVelocity) * 40;  // 2x faster (was 20)
                    ball.vx = grabber.vx * 3.0 + Math.cos(releaseAngle) * (6 + releaseSpeed);  // 2x faster
                    ball.vy = grabber.vy - 4 + Math.sin(releaseAngle) * releaseSpeed * 0.6;  // 2x faster
                    ball.grabbedBy = null;
                    ball.grabAngle = 0;
                    ball.grabAngularVelocity = 0;
                    grabber.hasBall = false;
                }
            } else {
                ball.vy += GRAVITY;
                ball.vx *= BALL_DAMPING;
                ball.x += ball.vx;
                ball.y += ball.vy;
            }
            
            // Ball boundaries
            if (ball.x < BALL_RADIUS) { ball.x = BALL_RADIUS; ball.vx = -ball.vx * BALL_BOUNCE_DAMPING; }
            if (ball.x > GAME_WIDTH - BALL_RADIUS) { ball.x = GAME_WIDTH - BALL_RADIUS; ball.vx = -ball.vx * BALL_BOUNCE_DAMPING; }
            if (ball.y > GAME_HEIGHT - GROUND_HEIGHT - BALL_RADIUS) { 
                ball.y = GAME_HEIGHT - GROUND_HEIGHT - BALL_RADIUS; 
                ball.vy = -ball.vy * BALL_BOUNCE_DAMPING; 
            }
            if (ball.y < BALL_RADIUS) { ball.y = BALL_RADIUS; ball.vy = -ball.vy * BALL_BOUNCE_DAMPING; }
            
            // Goal detection
            if (ball.x <= BALL_RADIUS && ball.y > GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT) {
                score.right++;
                updateScore();
                resetPositions();
            } else if (ball.x >= GAME_WIDTH - BALL_RADIUS && ball.y > GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT) {
                score.left++;
                updateScore();
                resetPositions();
            }
            
            // Ball-slime collisions
            [gameState.leftSlime, gameState.rightSlime].forEach((slime, idx) => {
                const slimeName = idx === 0 ? 'left' : 'right';
                const otherSlime = idx === 0 ? gameState.rightSlime : gameState.leftSlime;
                const dx = ball.x - slime.x;
                const dy = ball.y - slime.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < SLIME_RADIUS + BALL_RADIUS) {
                    // If ball is grabbed by opponent, check if we can knock it out
                    if (ball.grabbedBy && ball.grabbedBy !== slimeName) {
                        const angle = Math.atan2(dy, dx);
                        const speed = Math.sqrt(slime.vx * slime.vx + slime.vy * slime.vy);

                        // If slime is moving fast enough, knock the ball out
                        if (speed > 2 || Math.abs(slime.vy) > 5) {
                            ball.grabbedBy = null;
                            ball.grabAngle = 0;
                            ball.grabAngularVelocity = 0;
                            otherSlime.hasBall = false;

                            // Apply knockback force (2x faster)
                            ball.vx = Math.cos(angle) * 16 + slime.vx;
                            ball.vy = Math.sin(angle) * 16 + slime.vy;
                        }
                    }
                    // Check if slime is trying to grab an ungrabbed ball
                    else if (slime.isGrabbing && !ball.grabbedBy) {
                        ball.grabbedBy = slimeName;
                        ball.grabAngle = Math.atan2(dy, dx);
                        ball.grabAngularVelocity = 0;
                        slime.hasBall = true;
                    }
                    // Normal collision if not grabbing
                    else if (!ball.grabbedBy) {
                        const angle = Math.atan2(dy, dx);
                        const targetX = slime.x + Math.cos(angle) * (SLIME_RADIUS + BALL_RADIUS);
                        const targetY = slime.y + Math.sin(angle) * (SLIME_RADIUS + BALL_RADIUS);

                        // Only collide if ball is above slime center (semicircle collision)
                        if (ball.y < slime.y || Math.abs(angle) < Math.PI * 0.5) {
                            ball.x = targetX;
                            ball.y = targetY;

                            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            ball.vx = Math.cos(angle) * speed * 3.0 + slime.vx * 1.0;
                            ball.vy = Math.sin(angle) * speed * 3.0 + slime.vy * 1.0;

                            const newSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            if (newSpeed > MAX_BALL_SPEED) {
                                const scale = MAX_BALL_SPEED / newSpeed;
                                ball.vx *= scale;
                                ball.vy *= scale;
                            }
                        }
                    }
                }
            });
        }

        function draw() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear
            ctx.fillStyle = '#0000FF';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Ground
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, GAME_HEIGHT - GROUND_HEIGHT, GAME_WIDTH, GROUND_HEIGHT);
            
            // Goals with nets
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;

            // Left goal
            ctx.beginPath();
            ctx.moveTo(0, GAME_HEIGHT - GROUND_HEIGHT);
            ctx.lineTo(GOAL_WIDTH, GAME_HEIGHT - GROUND_HEIGHT);
            ctx.moveTo(GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT);
            ctx.lineTo(GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT);
            ctx.stroke();

            // Left goal net
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            // Vertical net lines
            for (let i = 0; i < GOAL_WIDTH / 2; i += 10) {
                ctx.beginPath();
                ctx.moveTo(i, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT);
                ctx.lineTo(i, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.stroke();
            }
            // Horizontal net lines
            for (let j = GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT; j <= GAME_HEIGHT - GROUND_HEIGHT; j += 10) {
                ctx.beginPath();
                ctx.moveTo(0, j);
                ctx.lineTo(GOAL_WIDTH / 2, j);
                ctx.stroke();
            }

            // Reset for right goal
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;

            // Right goal
            ctx.beginPath();
            ctx.moveTo(GAME_WIDTH - GOAL_WIDTH, GAME_HEIGHT - GROUND_HEIGHT);
            ctx.lineTo(GAME_WIDTH, GAME_HEIGHT - GROUND_HEIGHT);
            ctx.moveTo(GAME_WIDTH - GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT);
            ctx.lineTo(GAME_WIDTH - GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT);
            ctx.stroke();

            // Right goal net
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            // Vertical net lines
            for (let i = GAME_WIDTH - GOAL_WIDTH / 2; i <= GAME_WIDTH; i += 10) {
                ctx.beginPath();
                ctx.moveTo(i, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT);
                ctx.lineTo(i, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.stroke();
            }
            // Horizontal net lines
            for (let j = GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT; j <= GAME_HEIGHT - GROUND_HEIGHT; j += 10) {
                ctx.beginPath();
                ctx.moveTo(GAME_WIDTH - GOAL_WIDTH / 2, j);
                ctx.lineTo(GAME_WIDTH, j);
                ctx.stroke();
            }

            // Draw goal line timers
            const drawGoalLineTimer = (slime, goalX, goalWidth) => {
                if (slime.goalLineTime > 0) {
                    const percentage = 1 - (slime.goalLineTime / 1);
                    const timerWidth = goalWidth * percentage;

                    ctx.strokeStyle = percentage > 0.3 ? '#FFFF00' : '#FF0000';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(goalX, GAME_HEIGHT - GROUND_HEIGHT + 10);
                    ctx.lineTo(goalX + timerWidth, GAME_HEIGHT - GROUND_HEIGHT + 10);
                    ctx.stroke();

                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3;
                }
            };

            // Check and draw timers for slimes camping in their own goals
            if (gameState.leftSlime.x < GOAL_WIDTH) {
                drawGoalLineTimer(gameState.leftSlime, 0, GOAL_WIDTH);
            }
            if (gameState.rightSlime.x > GAME_WIDTH - GOAL_WIDTH) {
                drawGoalLineTimer(gameState.rightSlime, GAME_WIDTH - GOAL_WIDTH, GOAL_WIDTH);
            }
            
            // Slimes
            const drawSlime = (slime, color, accentColor, isRight) => {
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(slime.x, slime.y, SLIME_RADIUS, Math.PI, 0);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = accentColor;
                ctx.beginPath();
                ctx.arc(slime.x, slime.y, SLIME_RADIUS - 5, Math.PI + 0.3, Math.PI + 0.7);
                ctx.arc(slime.x, slime.y, SLIME_RADIUS - 15, Math.PI + 0.7, Math.PI + 0.3, true);
                ctx.closePath();
                ctx.fill();

                // Add grab indicator if grabbing (visually removed but structure maintained)
                if (slime.isGrabbing) {
                    // No visual indicator shown
                }

                ctx.restore();

                // Eye
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                const eyeXOffset = isRight ? -SLIME_RADIUS * 0.3 : SLIME_RADIUS * 0.3;
                ctx.arc(slime.x + eyeXOffset, slime.y - SLIME_RADIUS * 0.3, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#000000';
                ctx.beginPath();
                const pupilXOffset = isRight ? -SLIME_RADIUS * 0.35 : SLIME_RADIUS * 0.35;
                ctx.arc(slime.x + pupilXOffset, slime.y - SLIME_RADIUS * 0.3, 2, 0, Math.PI * 2);
                ctx.fill();
            };
            
            drawSlime(gameState.leftSlime, '#00CED1', '#008B8B', false);
            drawSlime(gameState.rightSlime, '#DC143C', '#8B0000', true);
            
            // Ball
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fill();
        }

        function gameLoop(currentTime) {
            if (!gameActive) return;

            // Implement frame rate limiting to 60 FPS
            const targetFrameTime = 1000 / 60; // 60 FPS = ~16.67ms per frame

            if (currentTime - lastFrameTime >= targetFrameTime) {
                updatePhysics();
                draw();
                lastFrameTime = currentTime;
            }

            animationId = requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>